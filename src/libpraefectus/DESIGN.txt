Object/Event System
===================

Praefectus uses a three-layer system of contexts to ensure consistency of both
simulation state and network topology.

Contexts
--------

A context (context.h) is a collection of any number of objects (object.h) and
events (event.h). An object is a container of state, both present and
historical, whereas an event is a *spontaneous* mutation of object
state. Events may be inserted and removed at any time, even at times not
corresponding to the time of the event.

Thus, a context allows for consistent handling of a sequence of events even if
they arrive out of order or late, even as the simulation is advancing
independently of the event inflow; all nodes which have accepted the same
set of events will have exactly the same state for the context.

Application Layer
-----------------

The application layer is the inner-most layer in which application-defined
logic is performed.

Transaction Layer
-----------------

The transaction layer sits atop the application layer. It controls the
acceptance and redaction of application events according to voting performed by
various nodes as well as timing considerations.

Application events entering the transaction layer are associated with a
time-out. An incomming event is initially inserted into the application layer,
but is redacted if the time-out expires without there being sufficient votes
for the event. Sufficient votes, even after the redaction, are sufficient to
keep the event in the application permanently (assuming the votes themselves
are not redacted).

An event with zero time-out is called a pessimistic event; it is not inserted
to the inner layer until sufficient votes have been cast. Non-pessimistic
events are said to be optimistic.

Metatransaction Layer
---------------------

The metatransaction layer sits atop the tranaction and application layers. It
ensures that nodes produce consistent results upon the joining and leaving of
other nodes.

Nodes are at any time associated with two permissions: GRANT and DENY. Events
(both to the metatransaction layer and the lower layer) originating from a node
only have effect if the node has the GRANT permission and does *not* have the
DENY permsission; such a node is said to be "alive". Permissions changes are
effected by a vote from a simple majority of existing nodes; such votes are
only counted from nodes that are alive, and only nodes that are alive count
towards the definition of "majority". Permissions changes only ever take the
effect of giving a node GRANT or DENY; thus, permissions changes are fully
idempotent.

Note that votes themselves are subject to retroactive node status changes; this
means that nodes do not all need to have a perfect global view of permissions
at any time.

Topology System
===============

The Topology System manages the conceptual communication between nodes and
manages the Object/Event System. It does not itself implement physical
communication or unicast information.

Due to the size of secure digital signatures, it is unfortunately necessary for
this system to dabble in raw byte representations in order to be able to batch
messages under one signature for the sake of efficiency.

Physical Interface
------------------

The Topology's interface to the Physical Communication System consists of four
primitives:

- Read an incoming message, if any. The message is returned merely as an array
  of bytes.

- Send a message (simply an array of bytes) to any set of nodes.

- Create a route to another node.

- Destroy a route to another node.

Note that, by design, no information is given on read about the origin of the
message; such information is derived implicitly from the digital signature on
the message.

High-Level Messages
-------------------

High-level messages are simply containers for one or more semantic
messages, signed with a digital signature. This grouping exists for the sake of
efficiency, since the signature is rather large by networking terms. Unlike
most formats used in Praefectus, high-level messages are not encoded with ASN.1
PER, but rather a simple octet-based scheme for the sake of simplicity of
implementation.

A high-level message begins with the following fixed header:

- 2 bytes; public key identity hint

- 32 bytes; signature

- 1 byte; flags

- 4 bytes; instant

The public key identity hint is equal to the first two bytes of the SHA-3 of
the signing node's public key (encoded as per the node-existence message),
which allow the receiver to more rapidly locate the correct public key to use
to verify the message. The hint is by no means unique to the public key. Nodes
are expected to fail to locate the correct public key (ie, assume the message
is invalid) if the hint is incorrect.

The signature consists of a pair of 128-bit little-endian integers,
corresponding to the (r,s) result pair of DSA. The signature is derived from
the SHA-3 of all bytes following the signature, including the flags and instant
fields.

Bit 0 of the flags byte indicates whether the message is fully-public. A
fully-public (bit is set) message may be redistributed immediately; semi-public
messages (if the bit is clear) should only be redistributed according to the
commit-validate rules. Semi-public messages are also passed into the
commit-validate system.

Bit 1 of the flags indicates whether the message is an asynchronous RPC. If
set, bit 0 is meaningless and must be 0, and the message will be discarded
after processing. Every semantic message type is either RPC-like or
distributable, and must be sent in a high-level message of the appropriate
type.

Other flags bits are currently reserved and must be zero.

The instant is a 32-bit little-endian integer indicating the instant at which
this message applies, in particular towards the commit-validate system.

After the header, extending to the end of the message, is a series of any
number of chunks. Each chunk consists of a byte indicating its length, followed
by exactly that many bytes, which are to be interpreted as a semantic
message.

A chunk which would have length zero instead indicates that the rest of the
message is garbage. This is used to prevent brute-forcing of message contents
from the commit hash.

Node Insertion
--------------

Node insertion is a rather difficult problem, since it by nature needs to occur
in real time, which cannot (to the author's knowledge) be rolled back
arbitrarily. This means that no node can assume that it's belief about the node
count is correct, which eliminates the possibility of using consensus. This is
further complicated by the need (or at least strong desirability) for nodes to
have unique 32-bit identifiers within the system.

The primary means of node addition is by endorsement. In endorsement, one node
single-handedly introduces a new node to the system, choosing an id for that
new node. This id is restricted according to the id of the endorsing node:

- All bits to the right of and including the left-most 1 bit on the must remain
  the same.

- Exactly one bit to the right of the left-most 1 bit shall be set.

For example, if ids were only 8 bits wide, node 1 (the bootstrap node) could
endorse nodes with the following ids:

- 00000011 (3)
- 00000101 (5)
- 00001001 (9)
- 00010001 (17)
- 00100001 (33)
- 01000001 (65)
- 10000001 (129)

The node with id 9 could endorse:

- 00011001 (23)
- 00101001 (41)
- 01001001 (73)
- 10001001 (137)

Note that all ids produced by endorsement are odd. Only nodes with odd ids may
endorse new nodes.

Endorsement allows new nodes to join the system very quickly while still
guaranteeing that their ids are unique. It also serves to limit the rate at
which new nodes are introduced. However, it is vulnerable to exhaustion, since
even the bootstrap node can only endorse up to 31 other nodes. Furthermore, the
disconnection of a node leaks all remaining ids it could have endorsed as well
as all descendents of those ids. This means that eventually the pool of
endorsable ids will dry up (though this will be rare outside of attack
situations).

Note that there is nothing stopping an endorsing node from endorsing multiple
new nodes with the same id. If this occurs, other nodes MUST accept messages
from both as if they were the same node, regardless of how nonsensical the
result should be. Such a configuration is a "chimera node".  Furthermore, other
nodes SHOULD begin voting to DENY the chimera, and the constituent parts of the
chimera SHOULD immediately restart the connection upon discovering the
situation.

In order to keep the system open even after endorsable ids have been exhausted,
an alternate (but much slower) system for obtaining node ids is provided, which
allocates non-zero, even node ids. It guarantees the insertion of the new node,
but is vulnerable to producing chimeras via random (or potentially deliberate)
collisions. This method of id generation is referred to as id commandeering.

Every network topology has a random 256-bit identifier. In order to join a
topology, a prospective node first queries an existing node for this identifier
and the current instant. The node then hashes this identifier, the current time
(encoded as a little-endian 4-byte integer), and its own public key (encoded
as a little-endian 512-bit integer), and populates the upper 31 bits of the id
with the first 31 bits of output from SHA-3; bit 0 is clear. If this produces
an id of 0, 2 is used instead. The node then gets its information signed by an
existing member of the network and can proceed with the joining process. The
same remarks regarding chimeras produced by endorsement applies here as well.

If a node receives a signed id commandeering message too far into the future or
the past, it SHOULD begin voting to DENY both the node that signed the
commandeerment and the node that commandeered the id. It MUST, however, accept
the message as-is.

Regardless of how a node id is derived, an existing member of the network signs
the information about the new node (including its network address, public key,
and information to derive the id). A node which receives such a valid signed
message MUST accept the new node into the system and continue proliferating
this message.

An endorsement messages is not considered valid if the endorser cannot endorse
the specified node id.
