Object/Event System
===================

Praefectus uses a three-layer system of contexts to ensure consistency of both
simulation state and network topology.

Contexts
--------

A context (context.h) is a collection of any number of objects (object.h) and
events (event.h). An object is a container of state, both present and
historical, whereas an event is a *spontaneous* mutation of object
state. Events may be inserted and removed at any time, even at times not
corresponding to the time of the event.

Thus, a context allows for consistent handling of a sequence of events even if
they arrive out of order or late, even as the simulation is advancing
independently of the event inflow; all nodes which have accepted the same
set of events will have exactly the same state for the context.

Application Layer
-----------------

The application layer is the inner-most layer in which application-defined
logic is performed.

Transaction Layer
-----------------

The transaction layer sits atop the application layer. It controls the
acceptance and redaction of application events according to voting performed by
various nodes as well as timing considerations.

Application events entering the transaction layer are associated with a
time-out. An incomming event is initially inserted into the application layer,
but is redacted if the time-out expires without there being sufficient votes
for the event. Sufficient votes, even after the redaction, are sufficient to
keep the event in the application permanently (assuming the votes themselves
are not redacted).

An event with zero time-out is called a pessimistic event; it is not inserted
to the inner layer until sufficient votes have been cast. Non-pessimistic
events are said to be optimistic.

Metatransaction Layer
---------------------

The metatransaction layer sits atop the tranaction and application layers. It
ensures that nodes produce consistent results upon the joining and leaving of
other nodes.

Nodes are at any time associated with two permissions: GRANT and DENY. Events
(both to the metatransaction layer and the lower layer) originating from a node
only have effect if the node has the GRANT permission and does *not* have the
DENY permsission; such a node is said to be "alive". Permissions changes are
effected by a vote from a simple majority of existing nodes; such votes are
only counted from nodes that are alive, and only nodes that are alive count
towards the definition of "majority". Permissions changes only ever take the
effect of giving a node GRANT or DENY; thus, permissions changes are fully
idempotent.

Note that votes themselves are subject to retroactive node status changes; this
means that nodes do not all need to have a perfect global view of permissions
at any time.

Topology System
===============

The Topology System manages the conceptual communication between nodes and
manages the Object/Event System. It does not itself implement physical
communication or unicast information.

Due to the size of secure digital signatures, it is unfortunately necessary for
this system to dabble in raw byte representations in order to be able to batch
messages under one signature for the sake of efficiency.

Physical Interface
------------------

The Topology's interface to the Physical Communication System consists of four
primitives:

- Read an incoming message, if any. The message is returned merely as an array
  of bytes.

- Send a message (simply an array of bytes) to any set of nodes.

- Create a route to another node.

- Destroy a route to another node.

Note that, by design, no information is given on read about the origin of the
message; such information is derived implicitly from the digital signature on
the message.

High-Level Messages
-------------------

High-level messages are simply containers for one or more semantic
messages, signed with a digital signature. This grouping exists for the sake of
efficiency, since the signature is rather large by networking terms. Unlike
most formats used in Praefectus, high-level messages are not encoded with ASN.1
PER, but rather a simple octet-based scheme for the sake of simplicity of
implementation.

A high-level message begins with the following fixed header:

- 2 bytes; public key identity hint

- 32 bytes; signature

- 1 byte; flags

- 4 bytes; instant

The public key identity hint is equal to the first two bytes of the SHA-3 of
the signing node's public key (encoded as per the node-existence message),
which allow the receiver to more rapidly locate the correct public key to use
to verify the message. The hint is by no means unique to the public key. Nodes
are expected to fail to locate the correct public key (ie, assume the message
is invalid) if the hint is incorrect.

The signature consists of a pair of 128-bit little-endian integers,
corresponding to the (r,s) result pair of DSA. The signature is derived from
the SHA-3 of all bytes following the signature, including the flags and instant
fields.

Bit 0 of the flags byte indicates whether the message is fully-public. A
fully-public (bit is set) message may be redistributed immediately; semi-public
messages (if the bit is clear) should only be redistributed according to the
commit-validate rules. Semi-public messages are also passed into the
commit-validate system.

Bit 1 of the flags indicates whether the message is an asynchronous RPC. If
set, bit 0 is meaningless, and the message will be discarded after
processing. Every semantic message type is either RPC-like or distributable,
and must be sent in a high-level message of the appropriate type.

Other flags bits are currently reserved and must be zero.

The instant is a 32-bit little-endian integer indicating the instant at which
this message applies, in particular towards the commit-validate system.

After the header, extending to the end of the message, is a series of any
number of chunks. Each chunk consists of a byte indicating its length, followed
by exactly that many bytes, which are to be interpreted as a semantic
message.

A chunk which would have length zero instead indicates that the rest of the
message is garbage. This is used to prevent brute-forcing of message contents
from the commit hash.
